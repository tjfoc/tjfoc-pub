// Code generated by protoc-gen-go. DO NOT EDIT.
// source: WorldStateMes.proto

/*
Package worldstate is a generated protocol buffer package.

It is generated from these files:
	WorldStateMes.proto

It has these top-level messages:
	Keys
	Datas
	CompareMes
	RequireMes
	SyncDataMes
	WDMes
*/
package worldstate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MesType int32

const (
	MesType_CM MesType = 0
	MesType_RM MesType = 1
	MesType_SM MesType = 2
	MesType_CF MesType = 3
	MesType_CS MesType = 4
)

var MesType_name = map[int32]string{
	0: "CM",
	1: "RM",
	2: "SM",
	3: "CF",
	4: "CS",
}
var MesType_value = map[string]int32{
	"CM": 0,
	"RM": 1,
	"SM": 2,
	"CF": 3,
	"CS": 4,
}

func (x MesType) String() string {
	return proto.EnumName(MesType_name, int32(x))
}
func (MesType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Keys struct {
	Key []string `protobuf:"bytes,1,rep,name=key" json:"key,omitempty"`
}

func (m *Keys) Reset()                    { *m = Keys{} }
func (m *Keys) String() string            { return proto.CompactTextString(m) }
func (*Keys) ProtoMessage()               {}
func (*Keys) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Keys) GetKey() []string {
	if m != nil {
		return m.Key
	}
	return nil
}

type Datas struct {
	Data map[string]string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Datas) Reset()                    { *m = Datas{} }
func (m *Datas) String() string            { return proto.CompactTextString(m) }
func (*Datas) ProtoMessage()               {}
func (*Datas) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Datas) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type CompareMes struct {
	Isinit       bool     `protobuf:"varint,1,opt,name=isinit" json:"isinit,omitempty"`
	Isdatamis    bool     `protobuf:"varint,2,opt,name=isdatamis" json:"isdatamis,omitempty"`
	Roothash     string   `protobuf:"bytes,3,opt,name=roothash" json:"roothash,omitempty"`
	Currentindex uint64   `protobuf:"varint,4,opt,name=currentindex" json:"currentindex,omitempty"`
	Buckethash   []string `protobuf:"bytes,5,rep,name=buckethash" json:"buckethash,omitempty"`
}

func (m *CompareMes) Reset()                    { *m = CompareMes{} }
func (m *CompareMes) String() string            { return proto.CompactTextString(m) }
func (*CompareMes) ProtoMessage()               {}
func (*CompareMes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CompareMes) GetIsinit() bool {
	if m != nil {
		return m.Isinit
	}
	return false
}

func (m *CompareMes) GetIsdatamis() bool {
	if m != nil {
		return m.Isdatamis
	}
	return false
}

func (m *CompareMes) GetRoothash() string {
	if m != nil {
		return m.Roothash
	}
	return ""
}

func (m *CompareMes) GetCurrentindex() uint64 {
	if m != nil {
		return m.Currentindex
	}
	return 0
}

func (m *CompareMes) GetBuckethash() []string {
	if m != nil {
		return m.Buckethash
	}
	return nil
}

type RequireMes struct {
	Indexs []uint64 `protobuf:"varint,1,rep,packed,name=indexs" json:"indexs,omitempty"`
}

func (m *RequireMes) Reset()                    { *m = RequireMes{} }
func (m *RequireMes) String() string            { return proto.CompactTextString(m) }
func (*RequireMes) ProtoMessage()               {}
func (*RequireMes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RequireMes) GetIndexs() []uint64 {
	if m != nil {
		return m.Indexs
	}
	return nil
}

type SyncDataMes struct {
	Currentindex uint64            `protobuf:"varint,1,opt,name=currentindex" json:"currentindex,omitempty"`
	Bkeys        map[uint64]string `protobuf:"bytes,2,rep,name=bkeys" json:"bkeys,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Bhash        map[uint64]string `protobuf:"bytes,3,rep,name=bhash" json:"bhash,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Bwd          map[uint64]*Datas `protobuf:"bytes,4,rep,name=bwd" json:"bwd,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncDataMes) Reset()                    { *m = SyncDataMes{} }
func (m *SyncDataMes) String() string            { return proto.CompactTextString(m) }
func (*SyncDataMes) ProtoMessage()               {}
func (*SyncDataMes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SyncDataMes) GetCurrentindex() uint64 {
	if m != nil {
		return m.Currentindex
	}
	return 0
}

func (m *SyncDataMes) GetBkeys() map[uint64]string {
	if m != nil {
		return m.Bkeys
	}
	return nil
}

func (m *SyncDataMes) GetBhash() map[uint64]string {
	if m != nil {
		return m.Bhash
	}
	return nil
}

func (m *SyncDataMes) GetBwd() map[uint64]*Datas {
	if m != nil {
		return m.Bwd
	}
	return nil
}

type WDMes struct {
	Type MesType `protobuf:"varint,1,opt,name=type,enum=worldstate.MesType" json:"type,omitempty"`
	// Types that are valid to be assigned to Realmes:
	//	*WDMes_Compare
	//	*WDMes_Require
	//	*WDMes_Sync
	Realmes isWDMes_Realmes `protobuf_oneof:"realmes"`
}

func (m *WDMes) Reset()                    { *m = WDMes{} }
func (m *WDMes) String() string            { return proto.CompactTextString(m) }
func (*WDMes) ProtoMessage()               {}
func (*WDMes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isWDMes_Realmes interface {
	isWDMes_Realmes()
}

type WDMes_Compare struct {
	Compare *CompareMes `protobuf:"bytes,2,opt,name=compare,oneof"`
}
type WDMes_Require struct {
	Require *RequireMes `protobuf:"bytes,3,opt,name=require,oneof"`
}
type WDMes_Sync struct {
	Sync *SyncDataMes `protobuf:"bytes,4,opt,name=sync,oneof"`
}

func (*WDMes_Compare) isWDMes_Realmes() {}
func (*WDMes_Require) isWDMes_Realmes() {}
func (*WDMes_Sync) isWDMes_Realmes()    {}

func (m *WDMes) GetRealmes() isWDMes_Realmes {
	if m != nil {
		return m.Realmes
	}
	return nil
}

func (m *WDMes) GetType() MesType {
	if m != nil {
		return m.Type
	}
	return MesType_CM
}

func (m *WDMes) GetCompare() *CompareMes {
	if x, ok := m.GetRealmes().(*WDMes_Compare); ok {
		return x.Compare
	}
	return nil
}

func (m *WDMes) GetRequire() *RequireMes {
	if x, ok := m.GetRealmes().(*WDMes_Require); ok {
		return x.Require
	}
	return nil
}

func (m *WDMes) GetSync() *SyncDataMes {
	if x, ok := m.GetRealmes().(*WDMes_Sync); ok {
		return x.Sync
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WDMes) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WDMes_OneofMarshaler, _WDMes_OneofUnmarshaler, _WDMes_OneofSizer, []interface{}{
		(*WDMes_Compare)(nil),
		(*WDMes_Require)(nil),
		(*WDMes_Sync)(nil),
	}
}

func _WDMes_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WDMes)
	// realmes
	switch x := m.Realmes.(type) {
	case *WDMes_Compare:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Compare); err != nil {
			return err
		}
	case *WDMes_Require:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Require); err != nil {
			return err
		}
	case *WDMes_Sync:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sync); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WDMes.Realmes has unexpected type %T", x)
	}
	return nil
}

func _WDMes_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WDMes)
	switch tag {
	case 2: // realmes.compare
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CompareMes)
		err := b.DecodeMessage(msg)
		m.Realmes = &WDMes_Compare{msg}
		return true, err
	case 3: // realmes.require
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequireMes)
		err := b.DecodeMessage(msg)
		m.Realmes = &WDMes_Require{msg}
		return true, err
	case 4: // realmes.sync
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SyncDataMes)
		err := b.DecodeMessage(msg)
		m.Realmes = &WDMes_Sync{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WDMes_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WDMes)
	// realmes
	switch x := m.Realmes.(type) {
	case *WDMes_Compare:
		s := proto.Size(x.Compare)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WDMes_Require:
		s := proto.Size(x.Require)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WDMes_Sync:
		s := proto.Size(x.Sync)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Keys)(nil), "worldstate.Keys")
	proto.RegisterType((*Datas)(nil), "worldstate.Datas")
	proto.RegisterType((*CompareMes)(nil), "worldstate.CompareMes")
	proto.RegisterType((*RequireMes)(nil), "worldstate.RequireMes")
	proto.RegisterType((*SyncDataMes)(nil), "worldstate.SyncDataMes")
	proto.RegisterType((*WDMes)(nil), "worldstate.WDMes")
	proto.RegisterEnum("worldstate.MesType", MesType_name, MesType_value)
}

func init() { proto.RegisterFile("WorldStateMes.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 488 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x51, 0x8b, 0xd3, 0x40,
	0x10, 0xc7, 0x9b, 0x66, 0xd3, 0x6b, 0xa7, 0x22, 0x71, 0x4f, 0xce, 0x50, 0x45, 0x4a, 0x10, 0xee,
	0x10, 0xac, 0x18, 0x1f, 0x2c, 0x3e, 0xde, 0x9d, 0x72, 0x22, 0x79, 0xd9, 0x0a, 0xf7, 0xbc, 0x4d,
	0x16, 0x2e, 0xb4, 0x4d, 0x7a, 0xd9, 0xad, 0x35, 0xdf, 0xc4, 0x67, 0x3f, 0x92, 0x9f, 0x48, 0x66,
	0x92, 0x36, 0xeb, 0x79, 0x55, 0x7c, 0xe9, 0x76, 0xa7, 0xff, 0xdf, 0xcc, 0xec, 0xcc, 0x9f, 0xc2,
	0xf1, 0x75, 0x51, 0x2e, 0xd3, 0x99, 0x91, 0x46, 0xc5, 0x4a, 0x4f, 0xd6, 0x65, 0x61, 0x0a, 0x0e,
	0x5b, 0x0c, 0x6a, 0x0c, 0x86, 0x01, 0xb0, 0xcf, 0xaa, 0xd2, 0xdc, 0x07, 0x77, 0xa1, 0xaa, 0xc0,
	0x19, 0xbb, 0x67, 0x03, 0x81, 0x5f, 0xc3, 0x5b, 0xf0, 0x2e, 0xa5, 0x91, 0x9a, 0xbf, 0x06, 0x96,
	0x4a, 0x23, 0xe9, 0xb7, 0x61, 0xf4, 0x74, 0xd2, 0xd2, 0x13, 0x12, 0xd0, 0xe7, 0x87, 0xdc, 0x94,
	0x95, 0x20, 0xe1, 0xe8, 0x1d, 0x0c, 0xf6, 0xa1, 0x36, 0xb1, 0xd3, 0x24, 0xe6, 0x8f, 0xc1, 0xfb,
	0x2a, 0x97, 0x1b, 0x15, 0x74, 0x29, 0x56, 0x5f, 0xde, 0x77, 0xa7, 0x4e, 0xf8, 0xc3, 0x01, 0xb8,
	0x28, 0x56, 0x6b, 0x59, 0x62, 0xb7, 0xfc, 0x04, 0x7a, 0x99, 0xce, 0xf2, 0xcc, 0x10, 0xdd, 0x17,
	0xcd, 0x8d, 0x3f, 0x83, 0x41, 0xa6, 0xb1, 0xd2, 0x2a, 0xd3, 0x94, 0xa4, 0x2f, 0xda, 0x00, 0x1f,
	0x41, 0xbf, 0x2c, 0x0a, 0x73, 0x23, 0xf5, 0x4d, 0xe0, 0x52, 0x85, 0xfd, 0x9d, 0x87, 0xf0, 0x20,
	0xd9, 0x94, 0xa5, 0xca, 0x4d, 0x96, 0xa7, 0xea, 0x5b, 0xc0, 0xc6, 0xce, 0x19, 0x13, 0xbf, 0xc5,
	0xf8, 0x73, 0x80, 0xf9, 0x26, 0x59, 0xa8, 0x3a, 0x83, 0x47, 0x03, 0xb1, 0x22, 0xe1, 0x0b, 0x00,
	0xa1, 0x6e, 0x37, 0x59, 0xdb, 0x23, 0x62, 0x9a, 0xc6, 0xc3, 0x44, 0x73, 0x0b, 0xbf, 0xbb, 0x30,
	0x9c, 0x55, 0x79, 0x82, 0x83, 0x40, 0xdd, 0xdd, 0xca, 0xce, 0x3d, 0x95, 0xa7, 0xe0, 0xcd, 0x17,
	0xaa, 0xc2, 0x37, 0xe1, 0xa4, 0x43, 0x7b, 0xd2, 0x56, 0xae, 0xc9, 0x39, 0x8a, 0xea, 0x81, 0xd7,
	0x00, 0x91, 0xcd, 0x83, 0xff, 0x4e, 0xa2, 0x68, 0x47, 0xd2, 0x44, 0x22, 0x70, 0xe7, 0xdb, 0x34,
	0x60, 0xc4, 0x8d, 0x0f, 0x72, 0xdb, 0xb4, 0xa6, 0x50, 0x3c, 0x9a, 0x02, 0xb4, 0x2d, 0xd8, 0x0b,
	0x66, 0xff, 0x58, 0x30, 0x91, 0xfb, 0x16, 0xfe, 0x8b, 0xfc, 0x04, 0xfd, 0x5d, 0x13, 0xf7, 0x70,
	0xa7, 0x36, 0x37, 0x8c, 0x1e, 0xfd, 0xe1, 0x51, 0xdb, 0x65, 0x3f, 0x1d, 0xf0, 0xae, 0x2f, 0x71,
	0x29, 0xa7, 0xc0, 0x4c, 0xb5, 0x56, 0x94, 0xe9, 0x61, 0x74, 0x6c, 0x53, 0xb1, 0xd2, 0x5f, 0xaa,
	0xb5, 0x12, 0x24, 0xe0, 0x11, 0x1c, 0x25, 0xb5, 0x2f, 0x9b, 0x0a, 0x27, 0xb6, 0xb6, 0xb5, 0xec,
	0x55, 0x47, 0xec, 0x84, 0xc8, 0x94, 0xb5, 0x4f, 0xc8, 0x86, 0x77, 0x98, 0xd6, 0x42, 0xc8, 0x34,
	0x42, 0xfe, 0x0a, 0x98, 0xae, 0xf2, 0x84, 0x7c, 0x39, 0x8c, 0x9e, 0x1c, 0x58, 0xc7, 0x55, 0x47,
	0x90, 0xec, 0x7c, 0x80, 0x25, 0xe4, 0x72, 0xa5, 0xf4, 0xcb, 0x37, 0x70, 0xd4, 0xb4, 0xcc, 0x7b,
	0xd0, 0xbd, 0x88, 0xfd, 0x0e, 0x9e, 0x22, 0xf6, 0x1d, 0x3c, 0x67, 0xb1, 0xdf, 0xa5, 0xf8, 0x47,
	0xdf, 0xa5, 0x73, 0xe6, 0xb3, 0x79, 0x8f, 0xfe, 0x0d, 0xde, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff,
	0x4d, 0x5e, 0xe7, 0xb0, 0x24, 0x04, 0x00, 0x00,
}
