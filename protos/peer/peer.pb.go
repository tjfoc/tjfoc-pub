// Code generated by protoc-gen-go. DO NOT EDIT.
// source: peer.proto

/*
Package peer is a generated protocol buffer package.

It is generated from these files:
	peer.proto

It has these top-level messages:
	BlockchainBool
	BlockchainHash
	PeerInfo
	PeerUpdateInfo
	MemberListInfo
	BlockchainNumber
	SearchMes
	SearchRes
	PeerStatusInfo
	Empty
*/
package peer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import block "github.com/tjfoc/tjfoc/protos/block"
import transaction "github.com/tjfoc/tjfoc/protos/transaction"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BlockchainBool struct {
	Ok  bool   `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	Err string `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *BlockchainBool) Reset()                    { *m = BlockchainBool{} }
func (m *BlockchainBool) String() string            { return proto.CompactTextString(m) }
func (*BlockchainBool) ProtoMessage()               {}
func (*BlockchainBool) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BlockchainBool) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *BlockchainBool) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type BlockchainHash struct {
	HashData []byte `protobuf:"bytes,1,opt,name=hashData,proto3" json:"hashData,omitempty"`
}

func (m *BlockchainHash) Reset()                    { *m = BlockchainHash{} }
func (m *BlockchainHash) String() string            { return proto.CompactTextString(m) }
func (*BlockchainHash) ProtoMessage()               {}
func (*BlockchainHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *BlockchainHash) GetHashData() []byte {
	if m != nil {
		return m.HashData
	}
	return nil
}

type PeerInfo struct {
	Id    string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Addr  string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
	State int32  `protobuf:"varint,3,opt,name=state" json:"state,omitempty"`
}

func (m *PeerInfo) Reset()                    { *m = PeerInfo{} }
func (m *PeerInfo) String() string            { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()               {}
func (*PeerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PeerInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PeerInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *PeerInfo) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

type PeerUpdateInfo struct {
	Typ   int32  `protobuf:"varint,1,opt,name=typ" json:"typ,omitempty"`
	Id    string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Addr  string `protobuf:"bytes,3,opt,name=addr" json:"addr,omitempty"`
	Data  string `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	Sign  string `protobuf:"bytes,5,opt,name=sign" json:"sign,omitempty"`
	Admin string `protobuf:"bytes,6,opt,name=admin" json:"admin,omitempty"`
}

func (m *PeerUpdateInfo) Reset()                    { *m = PeerUpdateInfo{} }
func (m *PeerUpdateInfo) String() string            { return proto.CompactTextString(m) }
func (*PeerUpdateInfo) ProtoMessage()               {}
func (*PeerUpdateInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PeerUpdateInfo) GetTyp() int32 {
	if m != nil {
		return m.Typ
	}
	return 0
}

func (m *PeerUpdateInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PeerUpdateInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *PeerUpdateInfo) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *PeerUpdateInfo) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *PeerUpdateInfo) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

type MemberListInfo struct {
	MemberList []*PeerInfo `protobuf:"bytes,1,rep,name=memberList" json:"memberList,omitempty"`
}

func (m *MemberListInfo) Reset()                    { *m = MemberListInfo{} }
func (m *MemberListInfo) String() string            { return proto.CompactTextString(m) }
func (*MemberListInfo) ProtoMessage()               {}
func (*MemberListInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MemberListInfo) GetMemberList() []*PeerInfo {
	if m != nil {
		return m.MemberList
	}
	return nil
}

type BlockchainNumber struct {
	Number uint64 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
}

func (m *BlockchainNumber) Reset()                    { *m = BlockchainNumber{} }
func (m *BlockchainNumber) String() string            { return proto.CompactTextString(m) }
func (*BlockchainNumber) ProtoMessage()               {}
func (*BlockchainNumber) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *BlockchainNumber) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

type SearchMes struct {
	Key  [][]byte `protobuf:"bytes,1,rep,name=key,proto3" json:"key,omitempty"`
	Type uint32   `protobuf:"varint,2,opt,name=type" json:"type,omitempty"`
}

func (m *SearchMes) Reset()                    { *m = SearchMes{} }
func (m *SearchMes) String() string            { return proto.CompactTextString(m) }
func (*SearchMes) ProtoMessage()               {}
func (*SearchMes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SearchMes) GetKey() [][]byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SearchMes) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type SearchRes struct {
	Res map[string]string `protobuf:"bytes,1,rep,name=res" json:"res,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SearchRes) Reset()                    { *m = SearchRes{} }
func (m *SearchRes) String() string            { return proto.CompactTextString(m) }
func (*SearchRes) ProtoMessage()               {}
func (*SearchRes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SearchRes) GetRes() map[string]string {
	if m != nil {
		return m.Res
	}
	return nil
}

type PeerStatusInfo struct {
	DiskUsedPercent      map[string]float64 `protobuf:"bytes,1,rep,name=diskUsedPercent" json:"diskUsedPercent,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	DiskTotal            map[string]uint64  `protobuf:"bytes,2,rep,name=diskTotal" json:"diskTotal,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	MemUsedPercent       float64            `protobuf:"fixed64,3,opt,name=memUsedPercent" json:"memUsedPercent,omitempty"`
	MemTotal             uint64             `protobuf:"varint,4,opt,name=memTotal" json:"memTotal,omitempty"`
	SingleCPUUsedPercent []float64          `protobuf:"fixed64,5,rep,packed,name=singleCPUUsedPercent" json:"singleCPUUsedPercent,omitempty"`
	TotalCPUUsedPercent  float64            `protobuf:"fixed64,6,opt,name=totalCPUUsedPercent" json:"totalCPUUsedPercent,omitempty"`
	WsRateTotal          float64            `protobuf:"fixed64,7,opt,name=wsRateTotal" json:"wsRateTotal,omitempty"`
	WsRateFromLast       float64            `protobuf:"fixed64,8,opt,name=wsRateFromLast" json:"wsRateFromLast,omitempty"`
	WsRateEverySec10     float64            `protobuf:"fixed64,9,opt,name=wsRateEverySec10" json:"wsRateEverySec10,omitempty"`
}

func (m *PeerStatusInfo) Reset()                    { *m = PeerStatusInfo{} }
func (m *PeerStatusInfo) String() string            { return proto.CompactTextString(m) }
func (*PeerStatusInfo) ProtoMessage()               {}
func (*PeerStatusInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PeerStatusInfo) GetDiskUsedPercent() map[string]float64 {
	if m != nil {
		return m.DiskUsedPercent
	}
	return nil
}

func (m *PeerStatusInfo) GetDiskTotal() map[string]uint64 {
	if m != nil {
		return m.DiskTotal
	}
	return nil
}

func (m *PeerStatusInfo) GetMemUsedPercent() float64 {
	if m != nil {
		return m.MemUsedPercent
	}
	return 0
}

func (m *PeerStatusInfo) GetMemTotal() uint64 {
	if m != nil {
		return m.MemTotal
	}
	return 0
}

func (m *PeerStatusInfo) GetSingleCPUUsedPercent() []float64 {
	if m != nil {
		return m.SingleCPUUsedPercent
	}
	return nil
}

func (m *PeerStatusInfo) GetTotalCPUUsedPercent() float64 {
	if m != nil {
		return m.TotalCPUUsedPercent
	}
	return 0
}

func (m *PeerStatusInfo) GetWsRateTotal() float64 {
	if m != nil {
		return m.WsRateTotal
	}
	return 0
}

func (m *PeerStatusInfo) GetWsRateFromLast() float64 {
	if m != nil {
		return m.WsRateFromLast
	}
	return 0
}

func (m *PeerStatusInfo) GetWsRateEverySec10() float64 {
	if m != nil {
		return m.WsRateEverySec10
	}
	return 0
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func init() {
	proto.RegisterType((*BlockchainBool)(nil), "peer.BlockchainBool")
	proto.RegisterType((*BlockchainHash)(nil), "peer.BlockchainHash")
	proto.RegisterType((*PeerInfo)(nil), "peer.PeerInfo")
	proto.RegisterType((*PeerUpdateInfo)(nil), "peer.PeerUpdateInfo")
	proto.RegisterType((*MemberListInfo)(nil), "peer.MemberListInfo")
	proto.RegisterType((*BlockchainNumber)(nil), "peer.BlockchainNumber")
	proto.RegisterType((*SearchMes)(nil), "peer.SearchMes")
	proto.RegisterType((*SearchRes)(nil), "peer.SearchRes")
	proto.RegisterType((*PeerStatusInfo)(nil), "peer.PeerStatusInfo")
	proto.RegisterType((*Empty)(nil), "peer.Empty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Peer service

type PeerClient interface {
	Search(ctx context.Context, in *SearchMes, opts ...grpc.CallOption) (*SearchRes, error)
	NewTransaction(ctx context.Context, in *transaction.Transaction, opts ...grpc.CallOption) (*BlockchainBool, error)
	BlockchainGetHeight(ctx context.Context, in *BlockchainBool, opts ...grpc.CallOption) (*BlockchainNumber, error)
	BlockchainGetBlockByHash(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*block.Block, error)
	BlockchainGetBlockByHeight(ctx context.Context, in *BlockchainNumber, opts ...grpc.CallOption) (*block.Block, error)
	BlockchainGetTransaction(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*transaction.Transaction, error)
	BlockchainGetTransactionIndex(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*BlockchainNumber, error)
	BlockchainGetTransactionBlock(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*BlockchainNumber, error)
	GetMemberList(ctx context.Context, in *BlockchainBool, opts ...grpc.CallOption) (*MemberListInfo, error)
	UpdatePeer(ctx context.Context, in *PeerUpdateInfo, opts ...grpc.CallOption) (*BlockchainBool, error)
	GetPeerHealthData(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeerStatusInfo, error)
}

type peerClient struct {
	cc *grpc.ClientConn
}

func NewPeerClient(cc *grpc.ClientConn) PeerClient {
	return &peerClient{cc}
}

func (c *peerClient) Search(ctx context.Context, in *SearchMes, opts ...grpc.CallOption) (*SearchRes, error) {
	out := new(SearchRes)
	err := grpc.Invoke(ctx, "/peer.Peer/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) NewTransaction(ctx context.Context, in *transaction.Transaction, opts ...grpc.CallOption) (*BlockchainBool, error) {
	out := new(BlockchainBool)
	err := grpc.Invoke(ctx, "/peer.Peer/NewTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) BlockchainGetHeight(ctx context.Context, in *BlockchainBool, opts ...grpc.CallOption) (*BlockchainNumber, error) {
	out := new(BlockchainNumber)
	err := grpc.Invoke(ctx, "/peer.Peer/BlockchainGetHeight", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) BlockchainGetBlockByHash(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*block.Block, error) {
	out := new(block.Block)
	err := grpc.Invoke(ctx, "/peer.Peer/BlockchainGetBlockByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) BlockchainGetBlockByHeight(ctx context.Context, in *BlockchainNumber, opts ...grpc.CallOption) (*block.Block, error) {
	out := new(block.Block)
	err := grpc.Invoke(ctx, "/peer.Peer/BlockchainGetBlockByHeight", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) BlockchainGetTransaction(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*transaction.Transaction, error) {
	out := new(transaction.Transaction)
	err := grpc.Invoke(ctx, "/peer.Peer/BlockchainGetTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) BlockchainGetTransactionIndex(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*BlockchainNumber, error) {
	out := new(BlockchainNumber)
	err := grpc.Invoke(ctx, "/peer.Peer/BlockchainGetTransactionIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) BlockchainGetTransactionBlock(ctx context.Context, in *BlockchainHash, opts ...grpc.CallOption) (*BlockchainNumber, error) {
	out := new(BlockchainNumber)
	err := grpc.Invoke(ctx, "/peer.Peer/BlockchainGetTransactionBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) GetMemberList(ctx context.Context, in *BlockchainBool, opts ...grpc.CallOption) (*MemberListInfo, error) {
	out := new(MemberListInfo)
	err := grpc.Invoke(ctx, "/peer.Peer/GetMemberList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) UpdatePeer(ctx context.Context, in *PeerUpdateInfo, opts ...grpc.CallOption) (*BlockchainBool, error) {
	out := new(BlockchainBool)
	err := grpc.Invoke(ctx, "/peer.Peer/UpdatePeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerClient) GetPeerHealthData(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PeerStatusInfo, error) {
	out := new(PeerStatusInfo)
	err := grpc.Invoke(ctx, "/peer.Peer/GetPeerHealthData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Peer service

type PeerServer interface {
	Search(context.Context, *SearchMes) (*SearchRes, error)
	NewTransaction(context.Context, *transaction.Transaction) (*BlockchainBool, error)
	BlockchainGetHeight(context.Context, *BlockchainBool) (*BlockchainNumber, error)
	BlockchainGetBlockByHash(context.Context, *BlockchainHash) (*block.Block, error)
	BlockchainGetBlockByHeight(context.Context, *BlockchainNumber) (*block.Block, error)
	BlockchainGetTransaction(context.Context, *BlockchainHash) (*transaction.Transaction, error)
	BlockchainGetTransactionIndex(context.Context, *BlockchainHash) (*BlockchainNumber, error)
	BlockchainGetTransactionBlock(context.Context, *BlockchainHash) (*BlockchainNumber, error)
	GetMemberList(context.Context, *BlockchainBool) (*MemberListInfo, error)
	UpdatePeer(context.Context, *PeerUpdateInfo) (*BlockchainBool, error)
	GetPeerHealthData(context.Context, *Empty) (*PeerStatusInfo, error)
}

func RegisterPeerServer(s *grpc.Server, srv PeerServer) {
	s.RegisterService(&_Peer_serviceDesc, srv)
}

func _Peer_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).Search(ctx, req.(*SearchMes))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_NewTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(transaction.Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).NewTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/NewTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).NewTransaction(ctx, req.(*transaction.Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_BlockchainGetHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainBool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).BlockchainGetHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/BlockchainGetHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).BlockchainGetHeight(ctx, req.(*BlockchainBool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_BlockchainGetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).BlockchainGetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/BlockchainGetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).BlockchainGetBlockByHash(ctx, req.(*BlockchainHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_BlockchainGetBlockByHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).BlockchainGetBlockByHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/BlockchainGetBlockByHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).BlockchainGetBlockByHeight(ctx, req.(*BlockchainNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_BlockchainGetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).BlockchainGetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/BlockchainGetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).BlockchainGetTransaction(ctx, req.(*BlockchainHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_BlockchainGetTransactionIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).BlockchainGetTransactionIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/BlockchainGetTransactionIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).BlockchainGetTransactionIndex(ctx, req.(*BlockchainHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_BlockchainGetTransactionBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).BlockchainGetTransactionBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/BlockchainGetTransactionBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).BlockchainGetTransactionBlock(ctx, req.(*BlockchainHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_GetMemberList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockchainBool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).GetMemberList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/GetMemberList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).GetMemberList(ctx, req.(*BlockchainBool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_UpdatePeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerUpdateInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).UpdatePeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/UpdatePeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).UpdatePeer(ctx, req.(*PeerUpdateInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Peer_GetPeerHealthData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServer).GetPeerHealthData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/peer.Peer/GetPeerHealthData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServer).GetPeerHealthData(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Peer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "peer.Peer",
	HandlerType: (*PeerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Peer_Search_Handler,
		},
		{
			MethodName: "NewTransaction",
			Handler:    _Peer_NewTransaction_Handler,
		},
		{
			MethodName: "BlockchainGetHeight",
			Handler:    _Peer_BlockchainGetHeight_Handler,
		},
		{
			MethodName: "BlockchainGetBlockByHash",
			Handler:    _Peer_BlockchainGetBlockByHash_Handler,
		},
		{
			MethodName: "BlockchainGetBlockByHeight",
			Handler:    _Peer_BlockchainGetBlockByHeight_Handler,
		},
		{
			MethodName: "BlockchainGetTransaction",
			Handler:    _Peer_BlockchainGetTransaction_Handler,
		},
		{
			MethodName: "BlockchainGetTransactionIndex",
			Handler:    _Peer_BlockchainGetTransactionIndex_Handler,
		},
		{
			MethodName: "BlockchainGetTransactionBlock",
			Handler:    _Peer_BlockchainGetTransactionBlock_Handler,
		},
		{
			MethodName: "GetMemberList",
			Handler:    _Peer_GetMemberList_Handler,
		},
		{
			MethodName: "UpdatePeer",
			Handler:    _Peer_UpdatePeer_Handler,
		},
		{
			MethodName: "GetPeerHealthData",
			Handler:    _Peer_GetPeerHealthData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "peer.proto",
}

func init() { proto.RegisterFile("peer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 782 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xed, 0x6a, 0xeb, 0x46,
	0x10, 0xb5, 0x6c, 0xc9, 0xd7, 0x1e, 0xe7, 0x2a, 0xbe, 0x7b, 0x4d, 0x10, 0x82, 0x82, 0xd9, 0x42,
	0x71, 0x43, 0x30, 0x89, 0x0b, 0x25, 0x84, 0x16, 0x52, 0xd7, 0x6e, 0x12, 0x48, 0xd2, 0xb0, 0x4e,
	0x1e, 0x60, 0x63, 0x4d, 0x63, 0x61, 0x4b, 0x32, 0xda, 0x4d, 0x52, 0xff, 0xef, 0xd3, 0xf5, 0x59,
	0xfa, 0x10, 0x65, 0x77, 0x6d, 0x4b, 0xfe, 0x50, 0x43, 0xff, 0xcd, 0x1c, 0xcd, 0x9c, 0x3d, 0x3b,
	0x33, 0x9a, 0x05, 0x98, 0x23, 0xa6, 0xdd, 0x79, 0x9a, 0xc8, 0x84, 0xd8, 0xca, 0xf6, 0x1b, 0xcf,
	0xb3, 0x64, 0x3c, 0x35, 0x90, 0xff, 0x45, 0xa6, 0x3c, 0x16, 0x7c, 0x2c, 0xc3, 0x24, 0x36, 0x10,
	0xed, 0x81, 0xdb, 0x57, 0x11, 0xe3, 0x09, 0x0f, 0xe3, 0x7e, 0x92, 0xcc, 0x88, 0x0b, 0xe5, 0x64,
	0xea, 0x59, 0x6d, 0xab, 0x53, 0x63, 0xe5, 0x64, 0x4a, 0x9a, 0x50, 0xc1, 0x34, 0xf5, 0xca, 0x6d,
	0xab, 0x53, 0x67, 0xca, 0xa4, 0x27, 0xf9, 0x9c, 0x6b, 0x2e, 0x26, 0xc4, 0x87, 0xda, 0x84, 0x8b,
	0xc9, 0x80, 0x4b, 0xae, 0x33, 0x0f, 0xd8, 0xda, 0xa7, 0x03, 0xa8, 0x3d, 0x20, 0xa6, 0x37, 0xf1,
	0x1f, 0x89, 0xe2, 0x0e, 0x03, 0x1d, 0x51, 0x67, 0xe5, 0x30, 0x20, 0x04, 0x6c, 0x1e, 0x04, 0x2b,
	0x72, 0x6d, 0x93, 0x16, 0x38, 0x42, 0x72, 0x89, 0x5e, 0xa5, 0x6d, 0x75, 0x1c, 0x66, 0x1c, 0xfa,
	0x97, 0x05, 0xae, 0xa2, 0x79, 0x9a, 0x07, 0x5c, 0xa2, 0x26, 0x6b, 0x42, 0x45, 0x2e, 0xe6, 0x9a,
	0xcd, 0x61, 0xca, 0x5c, 0xd2, 0x97, 0x77, 0xe8, 0x2b, 0x39, 0x7a, 0x02, 0x76, 0xa0, 0x64, 0xda,
	0x06, 0x53, 0xb6, 0xc2, 0x44, 0xf8, 0x12, 0x7b, 0x8e, 0xc1, 0x94, 0xad, 0x64, 0xf0, 0x20, 0x0a,
	0x63, 0xaf, 0xaa, 0x41, 0xe3, 0xd0, 0x4b, 0x70, 0xef, 0x30, 0x7a, 0xc6, 0xf4, 0x36, 0x14, 0x52,
	0xab, 0xe8, 0x02, 0x44, 0x6b, 0xc4, 0xb3, 0xda, 0x95, 0x4e, 0xa3, 0xe7, 0x76, 0x75, 0x1f, 0x56,
	0xd7, 0x66, 0xb9, 0x08, 0x7a, 0x0c, 0xcd, 0xac, 0x78, 0xf7, 0xaf, 0x0a, 0x27, 0x47, 0x50, 0x8d,
	0xb5, 0xa5, 0x2f, 0x63, 0xb3, 0xa5, 0x47, 0xcf, 0xa0, 0x3e, 0x42, 0x9e, 0x8e, 0x27, 0x77, 0x28,
	0xd4, 0x75, 0xa7, 0xb8, 0xd0, 0x27, 0x1c, 0x30, 0x65, 0x2a, 0xd9, 0x72, 0x31, 0x47, 0x7d, 0xe1,
	0xcf, 0x4c, 0xdb, 0x34, 0x59, 0xa5, 0x30, 0x14, 0xe4, 0x18, 0x2a, 0x29, 0x8a, 0xa5, 0x28, 0xcf,
	0x88, 0x5a, 0x7f, 0xed, 0x32, 0x14, 0xc3, 0x58, 0xa6, 0x0b, 0xa6, 0x82, 0xfc, 0x1f, 0xa1, 0xb6,
	0x02, 0xb2, 0xa3, 0x74, 0xcb, 0xd5, 0x51, 0x2d, 0x70, 0xde, 0xf8, 0xec, 0x15, 0x97, 0xc5, 0x35,
	0xce, 0x45, 0xf9, 0xdc, 0xa2, 0x7f, 0xdb, 0xa6, 0x31, 0x23, 0xc9, 0xe5, 0xab, 0xd0, 0x25, 0x19,
	0xc1, 0x61, 0x10, 0x8a, 0xe9, 0x93, 0xc0, 0xe0, 0x01, 0xd3, 0x31, 0xc6, 0xab, 0xba, 0x7c, 0x9f,
	0xd5, 0x25, 0x0b, 0xef, 0x0e, 0x36, 0x63, 0x8d, 0xa6, 0x6d, 0x06, 0xf2, 0x0b, 0xd4, 0x15, 0xf4,
	0x98, 0x48, 0x3e, 0xf3, 0xca, 0x9a, 0xee, 0xdb, 0x42, 0x3a, 0x1d, 0x65, 0x88, 0xb2, 0x2c, 0xf2,
	0x1d, 0xb8, 0x11, 0x46, 0x79, 0x59, 0x6a, 0x30, 0x2c, 0xb6, 0x85, 0xaa, 0x69, 0x8e, 0x30, 0x32,
	0x27, 0xd9, 0xba, 0x21, 0x6b, 0x9f, 0xf4, 0xa0, 0x25, 0xc2, 0xf8, 0x65, 0x86, 0xbf, 0x3e, 0x3c,
	0xe5, 0x99, 0x9c, 0x76, 0xa5, 0x63, 0xb1, 0xbd, 0xdf, 0xc8, 0x29, 0x7c, 0x95, 0x2a, 0x79, 0x2b,
	0xa5, 0xaa, 0x0f, 0xdf, 0xf7, 0x89, 0xb4, 0xa1, 0xf1, 0x2e, 0x18, 0x97, 0x68, 0x44, 0x7c, 0xd2,
	0x91, 0x79, 0x48, 0xdd, 0xc5, 0xb8, 0xbf, 0xa5, 0x49, 0x74, 0xcb, 0x85, 0xf4, 0x6a, 0xe6, 0x2e,
	0x9b, 0x28, 0x39, 0x86, 0xa6, 0x41, 0x86, 0x6f, 0x98, 0x2e, 0x46, 0x38, 0x3e, 0x3b, 0xf5, 0xea,
	0x3a, 0x72, 0x07, 0xf7, 0xfb, 0xd0, 0xda, 0xd7, 0x8b, 0x8f, 0xc6, 0xc1, 0xca, 0x8d, 0x83, 0xff,
	0x13, 0xb8, 0x9b, 0x0d, 0xf8, 0x28, 0xdb, 0xce, 0x0f, 0xd3, 0x27, 0x70, 0x86, 0xd1, 0x5c, 0x2e,
	0x7a, 0xff, 0x38, 0x60, 0xab, 0xbe, 0x92, 0x13, 0xa8, 0x9a, 0x89, 0x25, 0x87, 0xf9, 0xf9, 0xbd,
	0x43, 0xe1, 0x1f, 0x6e, 0x0d, 0x34, 0x2d, 0x91, 0x3e, 0xb8, 0xf7, 0xf8, 0xfe, 0x98, 0x6d, 0x39,
	0xe2, 0x75, 0xf3, 0x3b, 0x2f, 0xf7, 0xc5, 0x6f, 0x99, 0xf4, 0xcd, 0xed, 0x47, 0x4b, 0x64, 0x08,
	0x5f, 0x33, 0xec, 0x0a, 0xe5, 0x35, 0x86, 0x2f, 0x13, 0x49, 0xf6, 0x86, 0xfb, 0x47, 0xdb, 0xa8,
	0xf9, 0xa3, 0x69, 0x89, 0x5c, 0x82, 0xb7, 0x41, 0xa3, 0x9d, 0xfe, 0x42, 0xaf, 0xcb, 0x1d, 0x2e,
	0x85, 0xfa, 0x07, 0x5d, 0xb3, 0xab, 0x35, 0x4c, 0x4b, 0x64, 0x00, 0xfe, 0x5e, 0x06, 0xa3, 0xa7,
	0xe0, 0xe4, 0x1d, 0x96, 0xdb, 0x2d, 0x1d, 0xf9, 0xe2, 0xec, 0xd7, 0x51, 0x58, 0x32, 0x5a, 0x22,
	0xbf, 0xc3, 0x37, 0x45, 0x6c, 0x37, 0x71, 0x80, 0x7f, 0x16, 0x50, 0x16, 0x97, 0xe9, 0x3f, 0x08,
	0x35, 0xfe, 0xbf, 0x09, 0x7f, 0x86, 0xcf, 0x57, 0x28, 0xb3, 0x25, 0x5d, 0xd0, 0xb8, 0x25, 0xba,
	0xb9, 0xcc, 0x69, 0x89, 0x5c, 0x00, 0x98, 0x27, 0x46, 0x4f, 0x5f, 0x2b, 0xdb, 0x30, 0xd9, 0xc3,
	0x53, 0x38, 0x39, 0xe7, 0xf0, 0xe5, 0x0a, 0xa5, 0x0a, 0xbe, 0x46, 0x3e, 0x93, 0xfa, 0xf9, 0x23,
	0x0d, 0x13, 0xac, 0xc7, 0xda, 0x6f, 0xed, 0xdb, 0x58, 0xb4, 0xf4, 0x5c, 0xd5, 0x8f, 0xf1, 0x0f,
	0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x65, 0x0a, 0xb5, 0xc3, 0xc0, 0x07, 0x00, 0x00,
}
